内存管理
===

3.1 内存管理
---

+ strdup() 函数用来复制一个字符串
  > 注意：在 PHP 内核中，大多数情况下都不应改直接使用 C 语言中自带着 malloc、free、strdup、realloc、calloc 等操作内存的函数，而应使用内核提供的操作内存的函数，这样可以由内核整体统一的来管理内存。

+ Free the Mallocs
  > 在书写代码时需要保证在层层嵌套调用中对某块内存的使用都是正确的，且会及时释放的。

+ 错误处理
  > 为了实现从用户端(PHP语言中)跳出，需要使用一种方法来完全跳出一个活动请求。  
  > 这个功能是在内核中实现的：在一个请求的开始设置一个跳出地址，然后在任何 die() 或 exit() 调用或在遇到任何关键错误 (E_ERROR) 时执行一个 longjmp() 以跳转到该跳出地址。  
  > 当 php_error_docref 函数被调用的时候便会触发内核中的错误处理机制，根据错误级别来决定是否调用 longjmp 来终止当前请求并退出 call_function 函数，从而 efree 函数便永远不会被执行了。  

+ Zend 内存管理器
  > Zend Memory Manager，简称 ZendMM、ZMM。  
  > 除了提供隐式的内存清除功能之外，ZendMM 还能够根据 php.ini 中 memory_limit 设置来控制每一次内存请求行为。

+ void *estrndup(void *ptr，int len)  
  > 此函数能够分配 len+1 个字节的内存并且从 ptr 处复制 len 个字节到最新分配的块。

3.2 引用计数
---

+ 写时复制机制
  ```c
  $a = 1;
  $b = $a;
  $b += 5;
  ```
  > 内核首先查看 refcount__gc 属性，如果它大于 1 则为这个变化的变量从原 zval 结构中复制出一份新的专属于 $b 变量的 zval 来，并改变其值。

+ Change on Write
  ```c
  $a = 1;
  $b = &$a;
  $b += 5;
  ```
  > 尽管它的 refcount 等于 2，但是因为它的 is_ref 等于 1，所以也不会被复制，内核会直接的修改这个 zval 的值。

+ Separation Anxiety
  ```c
  $a = 1;
  $b = $a;
  $c = &$a;    
  ```
  > 在这种情况下，变量的值必须分离成两份完全独立的存在。$a 与 $c 共用一个 zval，$b 自己用一个 zval，尽管他们拥有同样的值，但是必须至少通过两个 zval 来实现。 

links
---

+ [目录](00.目录.md)
+ 上一节: [02.PHP变量在内核中的实现](02.PHP变量在内核中的实现.md)
+ 下一节: [04.配置编译环境](04.配置编译环境.md)
